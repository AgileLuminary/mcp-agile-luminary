import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
/**
 * Creates an Express middleware handler for stateful MCP sessions
 *
 * @param server - The MCP server instance to handle protocol logic
 * @param options - Configuration options for the handler
 * @returns An Express request handler function
 */
export function sseHandlers(serverFactory, options) {
    // Store active transports by session ID
    const transports = {};
    const postHandler = async (req, res, next) => {
        try {
            const sessionId = req.query.sessionId;
            const transport = transports[sessionId];
            if (transport) {
                await transport.handlePostMessage(req, res, req.body);
            }
            else {
                res.status(400).send('No transport found for sessionId');
            }
        }
        catch (error) {
            // Handle errors
            const sessionId = req.query.sessionId;
            if (options.onError) {
                options.onError(error, sessionId);
            }
            // Only send error response if headers haven't been sent yet
            if (!res.headersSent) {
                res.status(500).send('Internal server error');
            }
            // Pass to next error handler if available
            if (next) {
                next(error);
            }
        }
    };
    const getHandler = async (req, res, next) => {
        try {
            // Create SSE transport for legacy clients
            const transport = new SSEServerTransport('/messages', res);
            transport.onerror = (error) => {
                options.onError?.(error, transport.sessionId);
            };
            // Store the session ID for use in the close handler
            const sessionId = transport.sessionId;
            transport.onclose = () => {
                options.onClose?.(sessionId);
            };
            transports[transport.sessionId] = transport;
            res.on("close", () => {
                options.onClose?.(sessionId);
                delete transports[transport.sessionId];
            });
            await serverFactory().connect(transport);
        }
        catch (error) {
            // Handle errors
            if (options.onError) {
                options.onError(error, undefined);
            }
            // Only send error response if headers haven't been sent yet
            if (!res.headersSent) {
                res.status(500).send('Internal server error');
            }
            // Pass to next error handler if available
            if (next) {
                next(error);
            }
        }
    };
    return {
        postHandler: postHandler,
        getHandler: getHandler,
    };
}
//# sourceMappingURL=sse.js.map